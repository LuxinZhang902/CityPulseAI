"""Integrated SnowLeopard.ai client for CityPulse AI."""
import os
import requests
from typing import Dict, Any, Optional
from snowleopard import SnowLeopardPlaygroundClient

class SnowLeopardClient:
    """
    Integrated SnowLeopard.ai client that supports both:
    1. Direct API calls (original implementation)
    2. Playground client (new integrated approach)
    """
    
    def __init__(self, api_key: Optional[str] = None, use_playground: bool = True, datafile_id: Optional[str] = None):
        self.api_key = api_key or os.getenv("SNOWLEOPARD_API_KEY")
        self.use_playground = use_playground
        self.datafile_id = datafile_id or os.getenv("SNOWLEOPARD_DATAFILE_ID", "5baf5ba1d4344af3ba0a56d6869f3352")
        
        # Initialize clients
        if self.use_playground:
            try:
                self.playground_client = SnowLeopardPlaygroundClient(api_key=self.api_key)
                print("✅ SnowLeopard Playground client initialized")
            except Exception as e:
                print(f"⚠️  Playground client failed, falling back to direct API: {e}")
                self.use_playground = False
                self.playground_client = None
        
        # Direct API client (fallback)
        self.base_url = "https://api.snowleopard.ai/v1"
        
    def generate_sql(
        self,
        question: str,
        schema: Dict[str, Any],
        context: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Generate SQL query using SnowLeopard.ai.
        
        Tries Playground first, falls back to direct API if needed.
        
        Args:
            question: Natural language question
            schema: Database schema information (for direct API only)
            context: Additional context for query generation
            
        Returns:
            Dict with 'sql', 'explanation', and 'confidence'
        """
        if self.use_playground and self.playground_client:
            return self._generate_sql_playground(question, context)
        else:
            return self._generate_sql_direct(question, schema, context)
    
    def _generate_sql_playground(self, question: str, context: Optional[str] = None) -> Dict[str, Any]:
        """Generate SQL using SnowLeopard Playground client."""
        try:
            # Build the full question with context
            full_question = question
            if context:
                full_question = f"{context}\n\nQuestion: {question}"
            
            result = self.playground_client.retrieve(
                datafile_id=self.datafile_id,
                user_query=full_question
            )
            
            # Parse the result to extract SQL and explanation
            return self._parse_playground_result(result, question)
            
        except Exception as e:
            print(f"⚠️  Playground query failed: {e}")
            # Fall back to direct API
            return self._generate_sql_direct(question, {}, context)
    
    def _generate_sql_direct(
        self,
        question: str,
        schema: Dict[str, Any],
        context: Optional[str] = None
    ) -> Dict[str, Any]:
        """Generate SQL using direct SnowLeopard API (original implementation)."""
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "question": question,
            "schema": schema,
            "dialect": "sqlite",
            "context": context
        }
        
        try:
            response = requests.post(
                f"{self.base_url}/generate-sql",
                headers=headers,
                json=payload,
                timeout=30
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            # Fallback to local SQL generation if API fails
            print(f"⚠️  Direct API failed, using fallback: {e}")
            return self._fallback_sql_generation(question, schema)
    
    def _parse_playground_result(self, result, original_question: str) -> Dict[str, Any]:
        """Parse Playground result to extract SQL, data, and complete solution."""
        try:
            # Extract data from RetrieveResponse
            if hasattr(result, 'data') and result.data:
                data_item = result.data[0]
                sql = data_item.query
                rows = data_item.rows if data_item.rows else []
                
                # Extract query summary (handle both dict and object formats)
                query_summary = data_item.querySummary
                if isinstance(query_summary, dict):
                    explanation = query_summary.get('non_technical_explanation', f"Generated by SnowLeopard Playground for: {original_question}")
                    technical_details = query_summary.get('technical_details', '')
                else:
                    explanation = getattr(query_summary, 'non_technical_explanation', f"Generated by SnowLeopard Playground for: {original_question}")
                    technical_details = getattr(query_summary, 'technical_details', '')
                
                confidence = 0.9  # High confidence for Playground
                
                return {
                    "sql": sql,
                    "explanation": explanation,
                    "technical_details": technical_details,
                    "data": rows,  # Include the actual query results
                    "row_count": len(rows),
                    "confidence": confidence,
                    "source": "playground",
                    "has_solution": True
                }
            else:
                # Fallback if structure is unexpected
                return {
                    "sql": str(result),
                    "explanation": f"Playground response (may need manual SQL extraction): {original_question}",
                    "data": [],
                    "row_count": 0,
                    "confidence": 0.7,
                    "source": "playground",
                    "has_solution": False
                }
        except Exception as e:
            # Ultimate fallback
            return {
                "sql": str(result),
                "explanation": f"Error parsing Playground response: {str(e)}",
                "data": [],
                "row_count": 0,
                "confidence": 0.5,
                "source": "playground_error",
                "has_solution": False
            }
    
    def _fallback_sql_generation(
        self,
        question: str,
        schema: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Fallback SQL generation when both Playground and direct API fail.
        Uses rule-based approach for common query patterns.
        """
        question_lower = question.lower()
        
        # Emergency stress query
        if "emergency" in question_lower and "stress" in question_lower:
            sql = """
            SELECT 
                COALESCE(p.neighborhood, f.neighborhood) as neighborhood,
                COUNT(DISTINCT p.cad_id) as police_calls,
                COUNT(DISTINCT f.call_number) as fire_ems_calls,
                (COUNT(DISTINCT p.cad_id) * 1.0 + COUNT(DISTINCT f.call_number) * 1.2) as stress_score,
                AVG(p.latitude) as latitude,
                AVG(p.longitude) as longitude
            FROM sf_police_calls_rt p
            FULL OUTER JOIN sf_fire_ems_calls f 
                ON p.neighborhood = f.neighborhood
            WHERE datetime(p.received_datetime) >= datetime('now', '-24 hours')
                OR datetime(f.received_datetime) >= datetime('now', '-24 hours')
            GROUP BY COALESCE(p.neighborhood, f.neighborhood)
            ORDER BY stress_score DESC
            LIMIT 10
            """
            return {
                "sql": sql,
                "explanation": "Emergency stress analysis for past 24 hours (fallback)",
                "confidence": 0.85,
                "source": "fallback"
            }
        
        # Simple count queries
        if "how many" in question_lower:
            if "police" in question_lower:
                sql = "SELECT COUNT(*) as police_calls FROM sf_police_calls_rt"
            elif "fire" in question_lower or "ems" in question_lower:
                sql = "SELECT COUNT(*) as fire_ems_calls FROM sf_fire_ems_calls"
            elif "311" in question_lower:
                sql = "SELECT COUNT(*) as cases_311 FROM sf_311_cases"
            elif "disaster" in question_lower:
                sql = "SELECT COUNT(*) as disaster_events FROM sf_disaster_events"
            else:
                sql = "SELECT 'Please specify what to count' as message"
            
            return {
                "sql": sql,
                "explanation": "Simple count query (fallback)",
                "confidence": 0.80,
                "source": "fallback"
            }
        
        # Default fallback
        return {
            "sql": "SELECT 'Unable to generate SQL for this query' as message",
            "explanation": "Query not understood by fallback system",
            "confidence": 0.1,
            "source": "fallback"
        }
    
    def switch_to_playground(self, datafile_id: Optional[str] = None):
        """Switch to Playground mode."""
        if datafile_id:
            self.datafile_id = datafile_id
        
        try:
            self.playground_client = SnowLeopardPlaygroundClient(api_key=self.api_key)
            self.use_playground = True
            print(f"✅ Switched to Playground mode with datafile: {self.datafile_id}")
        except Exception as e:
            print(f"❌ Failed to switch to Playground: {e}")
            self.use_playground = False
    
    def switch_to_direct_api(self):
        """Switch to direct API mode."""
        self.use_playground = False
        print("✅ Switched to direct API mode")
    
    def get_mode(self) -> str:
        """Get current mode."""
        if self.use_playground:
            return f"Playground (datafile: {self.datafile_id})"
        else:
            return "Direct API"
